# GENERAL

This engine will use a tree-search to evaulate board positions at leaf nodes
using a board-evaluating function.

Some rules to keep in mind while designing this engine are:
	(DONE) Castling            		requires: has_moved flags for rooks and kings
	(DONE) Double pawn moves			requires: nothing (has moved?)
	(DONE) En passant					requires: knowing the enpassant square and source(s)
	(DONE) Promotion					requires: nothing
	Game over moments
		Dead positions			requires: library to check positions
		(DONE) Resignation		requires: nothing
		(DONE) 50 move rule			requires: counter to track 50-move rule (no pawn move and no captures for 50 moves, 100 ply)
		(DONE) Three-fold repetition	requires: hash to recall positions
		Checkmate

		Need to differentiate between a game-over state that is final, and one that is done as en exporatotry
		step by the computer. Sometimes, a game-over should be undo-able
		(make a move a test move?)

Optimizations and alpha-beta stuff:
	Legal move cacheing			requires: state->legalMoves hash

In previous attempts to create a chess engine, I created the logic for chess
but did not think ahead to the algorithm that would be used to decide what
move should be played by Computer players.

This version will use alpha-beta pruning to reduce the required number of
board position nodes that need to be searched. Other optimizations likely
exist, but the first step will be coding the game. From talking with a friend,
I was told memory is not an issue for this type of engine, as moves can be
made, and then unmade, using a stack. There is no exponential memory
requriement. The rate-limiting factor will be compute time. All optimizations
should be focused on evaluating FEWER nodes, and evaluating the nodes we must
FASTER.


Some Class information.
	[GAME]
		-BOARD
		-2x PLAYER
		-public void  play()
		
	[BOARD]
		[PIECE]
	[PLAYER]


for players to make choices, do we return boards or moves
	prolly boards ig. but display them as moves

50 move rule:





      a   b   c   d   e   f   g   h
     --- --- --- --- --- --- --- ---
   8| 0 | 1 |   |   |   |   |   |   |
     --- --- --- --- --- --- --- ---
   7| 8 |   |   |   |   |   |   |   |
     --- --- --- --- --- --- --- ---
   6| 16|   |   |   |   |   |   | p |
     --- --- --- --- --- --- --- ---
   5| 24|   |   |   | q | P |   |   |
     --- --- --- --- --- --- --- ---
   4| 32| p |   |   |   |   |   |   |
     --- --- --- --- --- --- --- ---
   3| 40| q |   |   |   |   |   | B |
     --- --- --- --- --- --- --- ---
   2| 48| 49| 50|   |   | n |   |   |
     --- --- --- --- --- --- --- ---
   1| 56| 57| 58| 59| 60| 61| 62| 63|
     --- --- --- --- --- --- --- ---


TODO:
 something in BruteForcePlayer()
 i think the apply and undo move doesnt quite work properly. i have some weird memory stuff going on here.